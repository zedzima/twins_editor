<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TWINS EDITOR</title>
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" id="favicon" href="data:image/svg+xml,%3Csvg width='40' height='40' viewBox='0 0 40 40' fill='none' xmlns='http://www.w3.org/2000/svg'%3E%3Cpath d='M39 40H33L21 8L12 32H6L9 24H3L0 16H6L9 24L15 8H21L18 0H24L39 40Z' fill='url(%23paint0_linear)'/%3E%3Cdefs%3E%3ClinearGradient id='paint0_linear' x1='19.5' y1='0' x2='19.5' y2='40' gradientUnits='userSpaceOnUse'%3E%3Cstop offset='0.05' stop-color='%235A24F2'/%3E%3Cstop offset='0.85' stop-color='%23A530E8'/%3E%3C/linearGradient%3E%3C/defs%3E%3C/svg%3E">
    
    <!-- Try to load logo from root, fallback to inline SVG -->
    <link rel="preload" as="image" href="/logo.png" onerror="this.remove()">
    <link rel="preload" as="image" href="/logo.jpg" onerror="this.remove()">
    <link rel="preload" as="image" href="/logo.svg" onerror="this.remove()">
    
    <!-- CodeMirror CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/codemirror.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/theme/monokai.min.css">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f5f5f5;
            --bg-tertiary: #e0e0e0;
            --text-primary: #333333;
            --text-secondary: #666666;
            --border-color: #cccccc;
            --accent: #2196F3;
            --success: #4CAF50;
            --warning: #FF9800;
            --error: #f44336;
            --keyword-gray: #9e9e9e;
            --keyword-blue: #2196F3;
            --keyword-green: #4CAF50;
            --keyword-red: #f44336;
        }

        body.dark {
            --bg-primary: #1e1e1e;
            --bg-secondary: #252525;
            --bg-tertiary: #333333;
            --text-primary: #e0e0e0;
            --text-secondary: #b0b0b0;
            --border-color: #444444;
        }

        /* Dark theme scrollbars */
        body.dark ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        body.dark ::-webkit-scrollbar-track {
            background: var(--bg-secondary);
        }

        body.dark ::-webkit-scrollbar-thumb {
            background: var(--bg-tertiary);
            border-radius: 5px;
        }

        body.dark ::-webkit-scrollbar-thumb:hover {
            background: #555;
        }

        body.dark * {
            scrollbar-color: var(--bg-tertiary) var(--bg-secondary);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Header with all controls in single line */
        .header {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 10px 20px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            overflow-x: auto;
        }

        .header-brand {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-right: 20px;
        }

        .logo {
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .logo img, .logo svg {
            width: 32px;
            height: 32px;
        }

        .header h1 {
            font-size: 20px;
            font-weight: 600;
            color: var(--text-primary);
            white-space: nowrap;
        }

        .header-brand .version {
            font-size: 11px;
            color: var(--text-secondary);
            margin-left: 8px;
            font-weight: 400;
        }

        .header-controls {
            display: flex;
            align-items: center;
            gap: 10px;
            flex: 1;
        }

        .control-group {
            display: flex;
            gap: 5px;
            align-items: center;
            padding: 0 10px;
            border-right: 1px solid var(--border-color);
        }

        .control-group:last-child {
            border-right: none;
        }

        button {
            padding: 5px 10px;
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: background 0.2s;
            white-space: nowrap;
        }

        button:hover {
            background: var(--border-color);
        }

        button.primary {
            background: var(--accent);
            color: white;
        }

        button.primary:hover {
            background: #1976D2;
        }

        .toggle-group {
            display: flex;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            overflow: hidden;
        }

        .toggle-group button {
            border-radius: 0;
            border: none;
        }

        .toggle-group button.active {
            background: var(--accent);
            color: white;
        }

        .toggle-group button:not(.active) {
            background: var(--bg-primary);
            color: var(--text-primary);
        }

        input[type="number"] {
            width: 50px;
            padding: 5px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 13px;
        }

        input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }

        label {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            font-size: 13px;
            white-space: nowrap;
        }

        select.language-selector,
        select.format-selector {
            padding: 4px 8px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-size: 12px;
            cursor: pointer;
        }

        .control-separator {
            display: inline-block;
            width: 1px;
            height: 20px;
            background: var(--border-color);
            margin: 0 5px;
        }

        /* Editor Container */
        .editor-container {
            flex: 1;
            display: flex;
            position: relative;
            overflow: hidden;
        }

        .pane {
            flex: 1;
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--border-color);
        }

        .pane:last-child {
            border-right: none;
        }

        .pane-header {
            padding: 8px 15px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            font-weight: 500;
            font-size: 14px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
        }

        .pane-header-left {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .pane-header-center {
            flex: 1;
            text-align: center;
            font-weight: 500;
        }

        .pane-header-right {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .pane-btn {
            padding: 4px 8px;
            background: var(--bg-primary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            border-radius: 3px;
            cursor: pointer;
            font-size: 12px;
            white-space: nowrap;
        }

        .pane-btn:hover {
            background: var(--border-color);
        }

        .pane-btn.close {
            padding: 2px 6px;
            font-weight: bold;
            color: var(--error);
        }

        .editor-wrapper {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        .CodeMirror {
            height: 100%;
            font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
            font-size: 14px;
        }

        /* Active line highlighting - brighter */
        .CodeMirror-activeline-background {
            background: rgba(33, 150, 243, 0.15) !important;
        }

        /* Mirror line highlighting */
        .cm-mirror-line {
            background: rgba(33, 150, 243, 0.25) !important;
        }

        /* Uniform text color in editor */
        .CodeMirror .cm-header,
        .CodeMirror .cm-link,
        .CodeMirror .cm-string,
        .CodeMirror .cm-def,
        .CodeMirror .cm-variable-2,
        .CodeMirror .cm-variable-3,
        .CodeMirror .cm-keyword,
        .CodeMirror .cm-quote,
        .CodeMirror .cm-comment,
        .CodeMirror .cm-tag,
        .CodeMirror .cm-attribute {
            color: var(--text-primary) !important;
        }

        body.dark .CodeMirror .cm-header,
        body.dark .CodeMirror .cm-link,
        body.dark .CodeMirror .cm-string,
        body.dark .CodeMirror .cm-def,
        body.dark .CodeMirror .cm-variable-2,
        body.dark .CodeMirror .cm-variable-3,
        body.dark .CodeMirror .cm-keyword,
        body.dark .CodeMirror .cm-quote,
        body.dark .CodeMirror .cm-comment,
        body.dark .CodeMirror .cm-tag,
        body.dark .CodeMirror .cm-attribute {
            color: var(--text-primary) !important;
        }

        /* Footer */
        .footer {
            padding: 8px 15px;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border-color);
            font-size: 13px;
        }

        .footer-row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
            flex-wrap: wrap;
        }

        .footer-label {
            font-weight: 600;
            color: var(--text-secondary);
        }

        .stats-row {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .stat-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .metric {
            padding: 3px 8px;
            background: transparent;
            border: 1px solid var(--border-color);
            border-radius: 3px;
            font-size: 12px;
        }

        /* Keyword chips with outline only */
        .keyword-chip {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            border-radius: 12px;
            cursor: pointer;
            transition: all 0.2s;
            background: transparent;
            border: 2px solid;
            font-size: 11px;
        }

        .keyword-chip:hover {
            transform: scale(1.05);
        }

        .keyword-chip.gray {
            border-color: var(--keyword-gray);
            color: var(--keyword-gray);
        }

        .keyword-chip.blue {
            border-color: var(--keyword-blue);
            color: var(--keyword-blue);
        }

        .keyword-chip.green {
            border-color: var(--keyword-green);
            color: var(--keyword-green);
        }

        .keyword-chip.red {
            border-color: var(--keyword-red);
            color: var(--keyword-red);
        }

        /* NLP Sidebars - overlay on editor panels */
        .sidebar {
            position: absolute;
            top: 0;
            width: 100%;
            max-width: 500px;
            height: 100%;
            background: var(--bg-primary);
            z-index: 50;
            overflow-y: auto;
            display: none;
        }

        /* Target NLP sidebar - opens on right side of source panel */
        #sidebarTarget {
            right: 0;
            border-left: 1px solid var(--border-color);
        }

        /* Source NLP sidebar - opens on left side of target panel */
        #sidebarSource {
            left: 0;
            border-right: 1px solid var(--border-color);
        }

        .sidebar.open {
            display: block;
        }

        .sidebar-content {
            padding: 20px;
        }

        .nlp-section {
            margin-bottom: 25px;
        }

        .nlp-section h3,
        .nlp-section h4 {
            margin-bottom: 10px;
            font-size: 14px;
            color: var(--text-primary);
            font-weight: 600;
        }


        .nlp-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }

        .nlp-table td {
            padding: 4px 8px;
            border-bottom: 1px solid var(--border-color);
        }

        .nlp-table td:first-child {
            font-weight: 500;
            cursor: pointer;
        }

        .nlp-table td:first-child.keyword-match {
            padding: 2px 6px;
            border-radius: 12px;
            border: 2px solid var(--accent);
            color: var(--accent);
        }

        .nlp-table td:nth-child(2) {
            text-align: center;
            width: 60px;
        }

        .nlp-table td:last-child {
            text-align: right;
            font-weight: 600;
            width: 80px;
        }

        .nlp-table .density-gray {
            color: var(--keyword-gray);
        }

        .nlp-table .density-blue {
            color: var(--keyword-blue);
        }

        .nlp-table .density-green {
            color: var(--keyword-green);
        }

        .nlp-table .density-red {
            color: var(--keyword-red);
        }

        /* Text overlays */
        .cm-keyword-focus {
            background: rgba(255, 235, 59, 0.4) !important;
            padding: 0 2px;
            border-radius: 2px;
        }

        /* Word-level diff highlights */
        .cm-diff-insert {
            background: rgba(255, 192, 203, 0.5);
            padding: 0 2px;
            border-radius: 2px;
        }

        .cm-diff-delete {
            background: rgba(244, 67, 54, 0.5);
            text-decoration: line-through;
            padding: 0 2px;
            border-radius: 2px;
        }

        .cm-diff-replace {
            background: rgba(255, 152, 0, 0.5);
            padding: 0 2px;
            border-radius: 2px;
        }

        /* Spell check highlights */
        .cm-spell-error {
            text-decoration: underline wavy red;
        }

        /* Hidden file inputs */
        input[type="file"] {
            display: none;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="header-brand">
            <div class="logo" id="logoContainer">
                <!-- Will be populated by JavaScript -->
            </div>
            <h1>TWINS EDITOR</h1>
            <span class="version">v2.4</span>
        </div>
        
        <div class="header-controls">
            <div class="control-group">
                <label>Mode:</label>
                <div class="toggle-group">
                    <button id="modeTranslation" class="active">Translation</button>
                    <button id="modeProofread">Proofread</button>
                </div>
            </div>
            
            <div class="control-group">
                <button id="undo">Undo</button>
                <button id="redo">Redo</button>
                <button id="saveTarget" class="primary">Save</button>
                <span class="control-separator"></span>
                <label>Format:</label>
                <select id="fileFormatSelector" class="format-selector">
                    <option value="markdown">Markdown</option>
                    <option value="text">Text</option>
                    <option value="json">JSON</option>
                    <option value="toml">TOML</option>
                    <option value="yaml">YAML</option>
                </select>
            </div>

            <div class="control-group">
                <label>Offset:</label>
                <button id="offsetMinus">−</button>
                <input type="number" id="offsetValue" value="0">
                <button id="offsetPlus">+</button>
                <button id="offsetReset">Reset</button>
                <label>
                    <input type="checkbox" id="lockScroll" checked>
                    Lock Scroll
                </label>
                <span class="control-separator"></span>
                <label>
                    <input type="checkbox" id="spellCheck">
                    Spell Check
                </label>
                <select id="languageSelector" class="language-selector">
                    <option value="en_US">English</option>
                    <option value="de_DE">German</option>
                    <option value="es_ES">Spanish</option>
                    <option value="fr_FR">French</option>
                    <option value="it_IT">Italian</option>
                    <option value="pt_PT">Portuguese</option>
                    <option value="pl_PL">Polish</option>
                    <option value="nl_NL">Dutch</option>
                    <option value="ru_RU">Russian</option>
                </select>
                <label>
                    <input type="checkbox" id="grammarCheck">
                    Grammar
                </label>
            </div>

            <div class="control-group">
                <button id="themeToggle">Theme</button>
            </div>

        </div>
    </div>

    <div class="editor-container">
        <div class="pane" id="leftPane">
            <div class="pane-header" id="leftHeader">
                <div class="pane-header-left">
                    <button class="pane-btn" id="openSourceBtn">Open Source</button>
                    <button class="pane-btn" id="openBaselineBtn" style="display: none;">Open Baseline</button>
                    <button class="pane-btn" id="sourceNlpBtn">NLP</button>
                </div>
                <div class="pane-header-center" id="leftHeaderLabel">SOURCE:</div>
                <div class="pane-header-right">
                    <button class="pane-btn close" id="closeSourceBtn">✕</button>
                </div>
            </div>
            <div class="editor-wrapper">
                <textarea id="sourceEditor"></textarea>
                <!-- Target NLP Sidebar (shows on source panel) -->
                <div class="sidebar" id="sidebarTarget">
                    <div class="sidebar-content">
                        <div class="nlp-section">
                            <h4>Top Lemmas (40)</h4>
                            <table class="nlp-table" id="targetLemmasTable"></table>
                        </div>
                        <div class="nlp-section">
                            <h4>Top Bigrams (40)</h4>
                            <table class="nlp-table" id="targetBigramsTable"></table>
                        </div>
                        <div class="nlp-section">
                            <h4>Top Trigrams (40)</h4>
                            <table class="nlp-table" id="targetTrigramsTable"></table>
                        </div>
                    </div>
                </div>
            </div>
            <div class="footer" id="leftFooter">
                <div class="footer-row stats-row">
                    <div class="stat-item">
                        <span class="footer-label">Chars:</span>
                        <span class="metric" id="leftChars">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="footer-label">Words:</span>
                        <span class="metric" id="leftWords">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="footer-label">Headings:</span>
                        <span class="metric" id="leftHeadings">0</span>
                    </div>
                </div>
                <div class="footer-row">
                    <span class="footer-label">Keywords:</span>
                    <div id="leftKeywords" style="display: inline-flex; gap: 5px; flex-wrap: wrap;"></div>
                </div>
            </div>
        </div>

        <div class="pane" id="rightPane">
            <div class="pane-header" id="rightHeader">
                <div class="pane-header-left">
                    <button class="pane-btn" id="openTargetBtn">Open Target</button>
                    <button class="pane-btn" id="targetNlpBtn">NLP</button>
                </div>
                <div class="pane-header-center" id="rightHeaderLabel">TARGET:</div>
                <div class="pane-header-right">
                    <button class="pane-btn close" id="closeTargetBtn">✕</button>
                </div>
            </div>
            <div class="editor-wrapper">
                <textarea id="targetEditor"></textarea>
                <!-- Source NLP Sidebar (shows on target panel) -->
                <div class="sidebar" id="sidebarSource">
                    <div class="sidebar-content">
                        <div class="nlp-section">
                            <h4>Top Lemmas (40)</h4>
                            <table class="nlp-table" id="sourceLemmasTable"></table>
                        </div>
                        <div class="nlp-section">
                            <h4>Top Bigrams (40)</h4>
                            <table class="nlp-table" id="sourceBigramsTable"></table>
                        </div>
                        <div class="nlp-section">
                            <h4>Top Trigrams (40)</h4>
                            <table class="nlp-table" id="sourceTrigramsTable"></table>
                        </div>
                    </div>
                </div>
            </div>
            <div class="footer" id="rightFooter">
                <div class="footer-row stats-row">
                    <div class="stat-item">
                        <span class="footer-label">Chars:</span>
                        <span class="metric" id="rightChars">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="footer-label">Words:</span>
                        <span class="metric" id="rightWords">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="footer-label">Headings:</span>
                        <span class="metric" id="rightHeadings">0</span>
                    </div>
                </div>
                <div class="footer-row">
                    <span class="footer-label">Keywords:</span>
                    <div id="rightKeywords" style="display: inline-flex; gap: 5px; flex-wrap: wrap;"></div>
                </div>
            </div>
        </div>
    </div>

    <!-- Hidden file inputs -->
    <input type="file" id="sourceFileInput" accept=".md,.txt,.json,.toml,.yaml,.yml">
    <input type="file" id="baselineFileInput" accept=".md,.txt,.json,.toml,.yaml,.yml">
    <input type="file" id="targetFileInput" accept=".md,.txt,.json,.toml,.yaml,.yml">

    <!-- CodeMirror JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/codemirror.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/mode/markdown/markdown.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/mode/toml/toml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/mode/yaml/yaml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.5/addon/selection/active-line.min.js"></script>
<script>
        // Global state
        const state = {
            mode: 'translation',
            sourceContent: '',
            targetContent: '',
            baselineContent: '',  // In translation mode: stores original target; In proofread mode: stores loaded baseline
            sourceFileName: '',
            targetFileName: '',
            baselineFileName: '',
            targetFileExtension: '.md',
            sourceFileType: 'markdown',  // markdown, toml, yaml, json, text
            targetFileType: 'markdown',
            offset: 0,
            lockScroll: true,
            theme: localStorage.getItem('theme') || 'light',
            grammarEnabled: false,
            spellCheckLanguage: 'en_US',
            welcomeActive: true,
            keywords: {
                left: [],
                right: []
            },
            nlpData: {
                left: { lemmas: [], bigrams: [], trigrams: [] },
                right: { lemmas: [], bigrams: [], trigrams: [] }
            }
        };

        // Get CodeMirror mode and file type from filename
        function getFileTypeAndMode(filename) {
            const ext = (filename.match(/\.([^.]+)$/)?.[1] || '').toLowerCase();
            switch (ext) {
                case 'toml':
                    return { type: 'toml', mode: 'toml' };
                case 'yaml':
                case 'yml':
                    return { type: 'yaml', mode: 'yaml' };
                case 'json':
                    return { type: 'json', mode: 'application/json' };
                case 'txt':
                    return { type: 'text', mode: 'text/plain' };
                case 'md':
                default:
                    return { type: 'markdown', mode: 'markdown' };
            }
        }

        // Extract only string values from TOML content (for stats)
        // Only counts visible content: string values, not keys, sections, or numbers
        function extractTomlValues(text) {
            const values = [];
            const lines = text.split('\n');

            for (let i = 0; i < lines.length; i++) {
                const line = lines[i];
                const trimmed = line.trim();

                // Skip comments, empty lines, section headers
                if (!trimmed || trimmed.startsWith('#') || /^\[+[\w.-]+\]+$/.test(trimmed)) {
                    continue;
                }

                // Multi-line string: key = """..."""
                if (trimmed.includes('= """')) {
                    let content = '';
                    const startMatch = line.match(/=\s*"""/);
                    if (startMatch) {
                        // Collect until closing """
                        let j = i;
                        let started = false;
                        while (j < lines.length) {
                            const currentLine = lines[j];
                            if (!started && currentLine.includes('= """')) {
                                started = true;
                                const afterStart = currentLine.split('= """')[1];
                                if (afterStart && afterStart.includes('"""')) {
                                    // Single line multi-line string
                                    content = afterStart.split('"""')[0];
                                    break;
                                }
                                content += afterStart + '\n';
                            } else if (started) {
                                if (currentLine.includes('"""')) {
                                    content += currentLine.split('"""')[0];
                                    i = j; // Skip processed lines
                                    break;
                                }
                                content += currentLine + '\n';
                            }
                            j++;
                        }
                        values.push(content.trim());
                    }
                    continue;
                }

                // Regular key = "value" or key = 'value'
                const stringMatch = trimmed.match(/^[\w.-]+\s*=\s*["'](.*)["']$/);
                if (stringMatch) {
                    values.push(stringMatch[1]);
                    continue;
                }

                // Array of strings on same line: key = ["a", "b", "c"]
                const inlineArrayMatch = trimmed.match(/^[\w.-]+\s*=\s*\[(.*)\]$/);
                if (inlineArrayMatch) {
                    const arrayContent = inlineArrayMatch[1];
                    const items = arrayContent.match(/"([^"]*)"/g);
                    if (items) {
                        items.forEach(item => values.push(item.replace(/"/g, '')));
                    }
                    continue;
                }
            }

            return values.join(' ');
        }

        // Extract keywords from TOML [meta] section
        function extractKeywordsFromToml(text) {
            // Find keywords = ["...", "..."] in the file
            const match = text.match(/^keywords\s*=\s*\[([\s\S]*?)\]/m);
            if (match) {
                const items = match[1].match(/"([^"]*)"/g);
                if (items) {
                    return items.map(item => item.replace(/"/g, ''));
                }
            }
            return [];
        }

        // Extract keywords from YAML
        function extractKeywordsFromYaml(text) {
            const keywords = [];
            const lines = text.split('\n');
            let inKeywords = false;

            for (const line of lines) {
                if (line.match(/^keywords:/i)) {
                    inKeywords = true;
                    // Check for inline array: keywords: [a, b, c]
                    const inlineMatch = line.match(/^keywords:\s*\[(.*)\]/i);
                    if (inlineMatch) {
                        const items = inlineMatch[1].split(',').map(s => s.trim().replace(/["']/g, ''));
                        keywords.push(...items.filter(s => s));
                        inKeywords = false;
                    }
                    continue;
                }
                if (inKeywords) {
                    if (line.match(/^\s+-\s+/)) {
                        const item = line.replace(/^\s+-\s+/, '').trim().replace(/["']/g, '');
                        if (item) keywords.push(item);
                    } else if (line.match(/^\w/) && !line.startsWith(' ')) {
                        inKeywords = false;
                    }
                }
            }
            return keywords;
        }

        // Extract only string values from YAML content (for stats)
        function extractYamlValues(text) {
            const values = [];
            const lines = text.split('\n');
            let inMultiline = false;
            let multilineContent = '';

            for (const line of lines) {
                const trimmed = line.trim();

                // Skip comments and empty lines
                if (trimmed.startsWith('#') || !trimmed) continue;

                // Handle multiline strings (| or >)
                if (inMultiline) {
                    if (line.startsWith(' ') || line.startsWith('\t')) {
                        multilineContent += trimmed + ' ';
                        continue;
                    } else {
                        values.push(multilineContent.trim());
                        multilineContent = '';
                        inMultiline = false;
                    }
                }

                // Check for multiline start
                if (trimmed.endsWith('|') || trimmed.endsWith('>')) {
                    inMultiline = true;
                    continue;
                }

                // Match key: "value" or key: 'value' or key: value
                const match = trimmed.match(/^[\w-]+:\s*["']?(.+?)["']?\s*$/);
                if (match && match[1]) {
                    const val = match[1].trim();
                    // Skip if value looks like a nested object, array marker, or number
                    if (val && !val.startsWith('{') && !val.startsWith('[') &&
                        val !== '|' && val !== '>' && isNaN(val)) {
                        values.push(val.replace(/["']/g, ''));
                    }
                    continue;
                }

                // Match array items: - "value" or - value
                const arrayMatch = trimmed.match(/^-\s+["']?(.+?)["']?$/);
                if (arrayMatch && arrayMatch[1]) {
                    const val = arrayMatch[1].trim();
                    if (val && isNaN(val)) {
                        values.push(val.replace(/["']/g, ''));
                    }
                }
            }

            if (multilineContent) {
                values.push(multilineContent.trim());
            }

            return values.join(' ');
        }

        // Get text content for statistics based on file type
        function getTextForStats(text, fileType) {
            switch (fileType) {
                case 'toml':
                    return extractTomlValues(text);
                case 'yaml':
                    return extractYamlValues(text);
                default:
                    return getMainBlock(text);
            }
        }

        // Get keywords based on file type
        function getKeywordsForFileType(text, fileType) {
            switch (fileType) {
                case 'toml':
                    return extractKeywordsFromToml(text);
                case 'yaml':
                    return extractKeywordsFromYaml(text);
                default:
                    return extractKeywords(text);
            }
        }


    // --- Native spellcheck helpers (no external dictionaries) ---
    function toBCP47(code) {
        if (!code) return 'en-US';
        // Convert "en_US" -> "en-US"
        return code.replace(/_/g, '-');
    }
    
    function setNativeSpellcheck(enabled) {
        const el = targetEditor && targetEditor.getInputField ? targetEditor.getInputField() : null;
        const host = targetEditor && targetEditor.getWrapperElement ? targetEditor.getWrapperElement() : null;
        if (el) {
            el.setAttribute('spellcheck', enabled ? 'true' : 'false');
            el.setAttribute('autocorrect', enabled ? 'on' : 'off');
            el.setAttribute('autocapitalize', 'off');
        }
        if (host) {
            host.setAttribute('spellcheck', enabled ? 'true' : 'false');
        }
    }
function setEditorLang(langCode) {
        const el = targetEditor && targetEditor.getInputField ? targetEditor.getInputField() : null;
        if (!el) return;
        const bcp = toBCP47(langCode);
        el.setAttribute('lang', bcp);
        // Also mark the host for good measure
        const host = targetEditor.getWrapperElement && targetEditor.getWrapperElement();
        if (host) host.setAttribute('lang', bcp);
    }
    // Backward-compatible stubs replacing CDN-based Typo.js logic
    async function loadSpellCheckerLanguage(lang) {
        state.spellCheckLanguage = lang;
        setEditorLang(lang);
        if (spellCheckEnabled) setNativeSpellcheck(true);
    }
    function applySpellCheck() {
        // With native spellcheck, we simply toggle the attribute.
        setNativeSpellcheck(spellCheckEnabled);
    }

        let sourceEditor, targetEditor;
        let spellCheckers = {}; // Store multiple language checkers
        let spellCheckEnabled = false;
        let currentSpellChecker = null;

        document.addEventListener('DOMContentLoaded', () => {
            loadLogo();
            initializeEditors();
            setupEventListeners();
            applyTheme(state.theme);
            updateUI();
            showWelcomeText();
            // Initialize native spellcheck language after editors exist
            setEditorLang(state.spellCheckLanguage);

        });

        function loadLogo() {
            const logoContainer = document.getElementById('logoContainer');
            const logoExtensions = ['png', 'jpg', 'jpeg', 'svg'];
            let logoLoaded = false;
            
            logoExtensions.forEach(ext => {
                if (!logoLoaded) {
                    const img = new Image();
                    img.src = `/logo.${ext}`;
                    img.onload = function() {
                        logoLoaded = true;
                        img.style.width = '32px';
                        img.style.height = '32px';
                        logoContainer.innerHTML = '';
                        logoContainer.appendChild(img);
                        
                        // Update favicon with loaded logo
                        const favicon = document.getElementById('favicon');
                        favicon.href = img.src;
                    };
                    img.onerror = function() {
                        if (!logoLoaded) {
                            logoContainer.innerHTML = `
                                <svg width="32" height="32" viewBox="0 0 40 40" fill="none" xmlns="http://www.w3.org/2000/svg">
                                    <path d="M39 40H33L21 8L12 32H6L9 24H3L0 16H6L9 24L15 8H21L18 0H24L39 40Z" fill="url(#paint0_linear)"/>
                                    <defs>
                                        <linearGradient id="paint0_linear" x1="19.5" y1="0" x2="19.5" y2="40" gradientUnits="userSpaceOnUse">
                                            <stop offset="0.05" stop-color="#5A24F2"/>
                                            <stop offset="0.85" stop-color="#A530E8"/>
                                        </linearGradient>
                                    </defs>
                                </svg>
                            `;
                        }
                    };
                }
            });
        }

        function showWelcomeText() {
            state.welcomeActive = true;
            
            // Unified welcome text for both panels
            const welcomeText = `# TWINS EDITOR v2.4

Dual-pane editor for translating and proofreading with real-time NLP analysis.

## Supported Formats

- **Markdown** (.md) - Rich text with headings, lists, links
- **Text** (.txt) - Plain text files
- **JSON** (.json) - Structured data
- **TOML** (.toml) - CMS content files
- **YAML** (.yaml, .yml) - Configuration files

## Translation Mode

Work with source and target documents side by side.

- **Left panel**: Source document (read-only reference)
- **Right panel**: Target document (editable)
- **Line mirroring**: Cursor position highlights corresponding line in other panel
- **Offset controls**: Adjust line alignment with +/- buttons when documents have different structure
- **Lock scroll**: Synchronized scrolling between panels (enabled by default)
- **Change tracking**: Edits tracked against original target for CHANGES block on save

## Proofread Mode

Compare current version against a baseline with visual diff highlighting.

- **Left panel**: Baseline document (load via Open Baseline button)
- **Right panel**: Current version (editable)
- **Real-time diff highlighting**:
  - Red strikethrough: Deleted words (shown in baseline)
  - Pink background: Added words (shown in current)
  - Orange background: Replaced words (shown in both)
- Changes update instantly as you edit

## Live Statistics

Footer shows real-time metrics for each panel:

- **Characters**: Total character count
- **Words**: Total word count
- **Headings**: Count of headings (# in Markdown, title/h1-h6 in TOML/YAML)

For TOML/YAML files, statistics count only string values (visible content), not keys or structure.

## Keyword Analysis

Keywords extracted automatically and shown as colored chips in footer.

**Sources**:
- Markdown: Line starting with "Keywords:" or # Keywords section
- TOML: keywords = ["term1", "term2"] in [meta] section
- YAML: keywords: [term1, term2]

**Density colors**:
- Gray: Low density (<1%)
- Blue: Normal density (1-2%)
- Green: Good density (2-3%)
- Red: High density (>3%)

Click any keyword chip to highlight all occurrences in the text.

## NLP Analysis

Each panel has its own NLP button in the header. Click to show/hide analysis overlay:

- **Source NLP** — analyzes source/baseline text
- **Target NLP** — analyzes target text

Each panel shows:

- **Top Lemmas**: Most frequent words with count and density %
- **Top Bigrams**: Two-word phrases with frequency
- **Top Trigrams**: Three-word phrases with frequency

Click any term to highlight occurrences. Keywords from your list are marked.

## Editing Tools

- **Spell Check**: Native browser spellcheck with multi-language support
- **Grammar Check**: Detects double spaces, repeated words, punctuation issues
- **Undo/Redo**: Full editing history
- **Theme Toggle**: Light/dark mode (preference saved)

## Keyboard Shortcuts

- **Ctrl/Cmd + S**: Save document
- **Ctrl/Cmd + O**: Open target file
- **Ctrl/Cmd + Z**: Undo
- **Ctrl/Cmd + Y**: Redo

## Saving

All formats save with auto-generated statistics:

**Markdown/Text/JSON**: Adds ## STATS and ## CHANGES sections after ---

**TOML/YAML**: Adds # === STATS === and # === CHANGES === as comments

Output filename: originalname_ready.ext

## Format Indicator

The Format selector in toolbar shows current file type. It auto-detects from file extension but can be changed manually if needed.

## Workflow

1. Select mode: Translation or Proofread
2. Open source/baseline file (left panel)
3. Open target file (right panel)
4. Edit target while monitoring stats and keywords
5. Use spell check and grammar tools as needed
6. Save to generate final document

Keywords: editor, translation, proofread, diff, toml, yaml, nlp`;

            sourceEditor.setValue(welcomeText);
            targetEditor.setValue(welcomeText);
            
            // Update footers to show live stats
            updateLiveFooter('left', welcomeText);
            updateLiveFooter('right', welcomeText);
        }

        function clearWelcomeText() {
            if (state.welcomeActive) {
                state.welcomeActive = false;
            }
        }

        function clearStats(side) {
            const prefix = side === 'left' ? 'left' : 'right';
            document.getElementById(`${prefix}Chars`).textContent = '0';
            document.getElementById(`${prefix}Words`).textContent = '0';
            document.getElementById(`${prefix}Headings`).textContent = '0';
            document.getElementById(`${prefix}Keywords`).innerHTML = '';
            
            // Clear NLP data
            state.nlpData[side === 'left' ? 'left' : 'right'] = {
                lemmas: [],
                bigrams: [],
                trigrams: [],
                keywords: []
            };
        }

        function initializeEditors() {
            sourceEditor = CodeMirror.fromTextArea(document.getElementById('sourceEditor'), {

                mode: 'markdown',
                lineNumbers: true,
                lineWrapping: true,
                readOnly: true,
                styleActiveLine: true,
                theme: state.theme === 'dark' ? 'monokai' : 'default',
                inputStyle: 'contenteditable',
                spellcheck: false
            });

            targetEditor = CodeMirror.fromTextArea(document.getElementById('targetEditor'), {

                mode: 'markdown',
                lineNumbers: true,
                lineWrapping: true,
                readOnly: false,
                styleActiveLine: true,
                theme: state.theme === 'dark' ? 'monokai' : 'default',
                inputStyle: 'contenteditable',
                spellcheck: true,
                autocorrect: 'on',
                autocapitalize: 'off'
            });

            sourceEditor.on('cursorActivity', () => {
                updateMirrorLine(sourceEditor, targetEditor);
            });

            targetEditor.on('cursorActivity', () => {
                updateMirrorLine(targetEditor, sourceEditor);
            });

            let updateTimeout = null;
            let sourceUpdateTimeout = null;
            
            targetEditor.on('change', (cm, change) => {
                if (state.welcomeActive && change.origin !== 'setValue') {
                    clearWelcomeText();
                }
                
                clearTimeout(updateTimeout);
                updateTimeout = setTimeout(() => {
                    if (!state.welcomeActive) {
                        updateLiveFooter('right', targetEditor.getValue());
                        if (state.mode === 'proofread') {
                            applyWordDiffHighlights();
                        }
                        if (spellCheckEnabled) {
                            applySpellCheck();
                        }
                    }
                }, 300);
            });

            sourceEditor.on('change', () => {
                clearTimeout(sourceUpdateTimeout);
                sourceUpdateTimeout = setTimeout(() => {
                    if (!state.welcomeActive) {
                        updateLiveFooter('left', sourceEditor.getValue());
                    }
                }, 300);
            });

            sourceEditor.on('scroll', () => {
                if (state.lockScroll) {
                    targetEditor.scrollTo(sourceEditor.getScrollInfo().left, sourceEditor.getScrollInfo().top);
                }
            });

            targetEditor.on('scroll', () => {
                if (state.lockScroll) {
                    sourceEditor.scrollTo(targetEditor.getScrollInfo().left, targetEditor.getScrollInfo().top);
                }
            });
        }

        async 
// legacy spellcheck loader removed in v9.6.1

// legacy applySpellCheck removed in v9.6.1


        function updateMirrorLine(fromEditor, toEditor) {
            toEditor.getAllMarks().forEach(mark => {
                if (mark.className === 'cm-mirror-line') {
                    mark.clear();
                }
            });
            
            const cursor = fromEditor.getCursor();
            const fromLine = cursor.line;
            
            let toLine;
            if (fromEditor === sourceEditor) {
                toLine = fromLine + state.offset;
            } else {
                toLine = fromLine - state.offset;
            }
            
            toLine = Math.max(0, Math.min(toLine, toEditor.lineCount() - 1));
            
            const lineText = toEditor.getLine(toLine);
            if (lineText !== null && lineText !== undefined) {
                toEditor.markText(
                    { line: toLine, ch: 0 },
                    { line: toLine, ch: lineText.length },
                    { className: 'cm-mirror-line' }
                );
            }
        }

        function setupEventListeners() {
            document.getElementById('modeTranslation').addEventListener('click', () => setMode('translation'));
            document.getElementById('modeProofread').addEventListener('click', () => setMode('proofread'));

            // Pane header buttons
            document.getElementById('openSourceBtn').addEventListener('click', openSourceFile);
            document.getElementById('openBaselineBtn').addEventListener('click', openBaselineFile);
            document.getElementById('openTargetBtn').addEventListener('click', openTargetFile);
            document.getElementById('closeSourceBtn').addEventListener('click', closeSourceFile);
            document.getElementById('closeTargetBtn').addEventListener('click', closeTargetFile);
            
            document.getElementById('saveTarget').addEventListener('click', saveTargetFile);

            document.getElementById('sourceFileInput').addEventListener('change', handleSourceFile);
            document.getElementById('baselineFileInput').addEventListener('change', handleBaselineFile);
            document.getElementById('targetFileInput').addEventListener('change', handleTargetFile);

            document.getElementById('offsetMinus').addEventListener('click', () => adjustOffset(-1));
            document.getElementById('offsetPlus').addEventListener('click', () => adjustOffset(1));
            document.getElementById('offsetReset').addEventListener('click', () => setOffset(0));
            document.getElementById('offsetValue').addEventListener('change', (e) => setOffset(parseInt(e.target.value) || 0));

            document.getElementById('lockScroll').addEventListener('change', (e) => {
                state.lockScroll = e.target.checked;
            });

            document.getElementById('themeToggle').addEventListener('click', toggleTheme);

            document.getElementById('undo').addEventListener('click', () => targetEditor.undo());
            document.getElementById('redo').addEventListener('click', () => targetEditor.redo());

            document.getElementById('spellCheck').addEventListener('change', (e) => {
                spellCheckEnabled = e.target.checked;
                applySpellCheck();
            });

            document.getElementById('languageSelector').addEventListener('change', (e) => {
                loadSpellCheckerLanguage(e.target.value);
            });

            document.getElementById('grammarCheck').addEventListener('change', (e) => {
                state.grammarEnabled = e.target.checked;
                applyGrammarCheck();
            });

            document.getElementById('fileFormatSelector').addEventListener('change', (e) => {
                const format = e.target.value;
                setFileFormat(format);
            });

            document.getElementById('sourceNlpBtn').addEventListener('click', () => {
                const sidebar = document.getElementById('sidebarSource');
                const btn = document.getElementById('sourceNlpBtn');
                sidebar.classList.toggle('open');
                if (sidebar.classList.contains('open')) {
                    btn.textContent = '✕ NLP';
                    updateNLPSidebar('source');
                } else {
                    btn.textContent = 'NLP';
                }
            });

            document.getElementById('targetNlpBtn').addEventListener('click', () => {
                const sidebar = document.getElementById('sidebarTarget');
                const btn = document.getElementById('targetNlpBtn');
                sidebar.classList.toggle('open');
                if (sidebar.classList.contains('open')) {
                    btn.textContent = '✕ NLP';
                    updateNLPSidebar('target');
                } else {
                    btn.textContent = 'NLP';
                }
            });

            document.addEventListener('keydown', (e) => {
                if ((e.ctrlKey || e.metaKey) && e.key === 's') {
                    e.preventDefault();
                    saveTargetFile();
                }
                if ((e.ctrlKey || e.metaKey) && e.key === 'o') {
                    e.preventDefault();
                    openTargetFile();
                }
            });
        }

        function setMode(mode) {
            state.mode = mode;

            document.getElementById('modeTranslation').classList.toggle('active', mode === 'translation');
            document.getElementById('modeProofread').classList.toggle('active', mode === 'proofread');

            // Show/hide appropriate buttons
            if (mode === 'translation') {
                document.getElementById('openSourceBtn').style.display = 'block';
                document.getElementById('openBaselineBtn').style.display = 'none';
                
                if (state.sourceContent) {
                    sourceEditor.setValue(state.sourceContent);
                } else {
                    sourceEditor.setValue('');
                    if (state.welcomeActive) {
                        showWelcomeText();
                    }
                }
                clearAllHighlights();
            } else {
                document.getElementById('openSourceBtn').style.display = 'none';
                document.getElementById('openBaselineBtn').style.display = 'block';
                
                // In proofread mode, use explicitly loaded baseline
                if (state.baselineFileName) {
                    sourceEditor.setValue(state.baselineContent);
                    applyWordDiffHighlights();
                } else {
                    sourceEditor.setValue('');
                    if (state.welcomeActive) {
                        showWelcomeText();
                    }
                }
            }

            updateHeaderLabels();

            if (!state.welcomeActive) {
                updateLiveFooter('left', sourceEditor.getValue());
                updateLiveFooter('right', targetEditor.getValue());
            }
        }

        function updateHeaderLabels() {
            // Update left panel header
            if (state.mode === 'translation') {
                const sourceName = state.sourceFileName || '';
                document.getElementById('leftHeaderLabel').textContent = sourceName ? `SOURCE: ${sourceName}` : 'SOURCE:';
            } else {
                const baselineName = state.baselineFileName || '';
                document.getElementById('leftHeaderLabel').textContent = baselineName ? `BASELINE: ${baselineName}` : 'BASELINE:';
            }

            // Update right panel header
            const targetName = state.targetFileName || '';
            document.getElementById('rightHeaderLabel').textContent = targetName ? `TARGET: ${targetName}` : 'TARGET:';
        }

        function openSourceFile() {
            document.getElementById('sourceFileInput').click();
        }

        function openBaselineFile() {
            document.getElementById('baselineFileInput').click();
        }

        function openTargetFile() {
            document.getElementById('targetFileInput').click();
        }

        function closeSourceFile() {
            state.sourceContent = '';
            state.sourceFileName = '';
            state.sourceFileType = 'markdown';

            // Only clear baseline if in proofread mode
            if (state.mode === 'proofread') {
                state.baselineContent = '';
                state.baselineFileName = '';
            }

            sourceEditor.setValue('');
            sourceEditor.setOption('mode', 'markdown');
            clearAllHighlights();
            updateHeaderLabels();
            clearStats('left');
            showWelcomeText();
        }

        function closeTargetFile() {
            state.targetContent = '';
            state.targetFileName = '';
            state.targetFileType = 'markdown';

            // Clear the baseline that was set from target in translation mode
            if (state.mode === 'translation') {
                state.baselineContent = '';
            }

            targetEditor.setValue('');
            targetEditor.setOption('mode', 'markdown');
            clearAllHighlights();
            updateHeaderLabels();
            clearStats('right');
            showWelcomeText();
        }

        function handleSourceFile(e) {
            const file = e.target.files[0];
            if (!file) return;

            clearWelcomeText();

            // Set file type and CodeMirror mode
            const { type, mode } = getFileTypeAndMode(file.name);
            state.sourceFileType = type;
            sourceEditor.setOption('mode', mode);

            const reader = new FileReader();
            reader.onload = (evt) => {
                const content = evt.target.result;
                state.sourceContent = content;
                state.sourceFileName = file.name;

                if (state.mode === 'translation') {
                    sourceEditor.setValue(content);
                }

                updateHeaderLabels();
                updateLiveFooter('left', content);
            };
            reader.readAsText(file);
            e.target.value = '';
        }

        function handleBaselineFile(e) {
            const file = e.target.files[0];
            if (!file) return;

            clearWelcomeText();

            // Set file type and CodeMirror mode for baseline
            const { type, mode } = getFileTypeAndMode(file.name);
            state.sourceFileType = type;
            sourceEditor.setOption('mode', mode);

            const reader = new FileReader();
            reader.onload = (evt) => {
                const content = evt.target.result;

                // In proofread mode, set baseline from loaded file
                state.baselineContent = content;
                state.baselineFileName = file.name;

                if (state.mode === 'proofread') {
                    sourceEditor.setValue(content);
                    applyWordDiffHighlights();
                }

                updateHeaderLabels();
                updateLiveFooter('left', content);
            };
            reader.readAsText(file);
            e.target.value = '';
        }

        function handleTargetFile(e) {
            const file = e.target.files[0];
            if (!file) return;

            clearWelcomeText();

            const ext = file.name.match(/\.(md|txt|json|toml|yaml|yml)$/i);
            if (ext) {
                state.targetFileExtension = ext[0];
            }

            // Set file type and CodeMirror mode
            const { type, mode } = getFileTypeAndMode(file.name);
            state.targetFileType = type;
            targetEditor.setOption('mode', mode);
            document.getElementById('fileFormatSelector').value = type;

            const reader = new FileReader();
            reader.onload = (evt) => {
                const content = evt.target.result;
                state.targetContent = content;
                state.targetFileName = file.name;

                // IMPORTANT: In translation mode, store original target as baseline for change tracking
                if (state.mode === 'translation') {
                    state.baselineContent = content;
                }

                targetEditor.setValue(content);

                // Apply diff highlights in proofread mode after loading target
                if (state.mode === 'proofread' && state.baselineContent) {
                    applyWordDiffHighlights();
                }

                updateHeaderLabels();
                updateLiveFooter('right', content);
            };
            reader.readAsText(file);
            e.target.value = '';
        }

        async function saveTargetFile() {
            const content = targetEditor.getValue();
            if (!content || state.welcomeActive) {
                alert('Nothing to save');
                return;
            }

            let finalContent;
            let suggestedName;
            const baseName = (state.targetFileName || 'document').replace(/\.(md|txt|json|toml|yaml|yml)$/i, '');
            suggestedName = `${baseName}_ready${state.targetFileExtension}`;

            if (state.targetFileType === 'toml' || state.targetFileType === 'yaml') {
                // For TOML/YAML, add stats as comments at the end
                const contentForStats = getTextForStats(content, state.targetFileType);
                const stats = generateStatsComment(contentForStats, state.targetFileType);
                const changes = generateWordChangesComment(state.targetFileType);

                finalContent = content;
                if (!finalContent.endsWith('\n')) {
                    finalContent += '\n';
                }
                finalContent += '\n' + stats;
                if (changes) {
                    finalContent += '\n\n' + changes;
                }
            } else {
                // For Markdown/Text/JSON, add stats and changes sections
                const mainBlock = getMainBlock(content);
                const stats = generateStats(mainBlock);
                const changes = generateWordChanges();

                finalContent = mainBlock;
                if (mainBlock && !mainBlock.endsWith('\n')) {
                    finalContent += '\n';
                }
                finalContent += '\n---\n\n';
                finalContent += stats;
                if (changes) {
                    finalContent += '\n\n' + changes;
                }
            }

            const blob = new Blob([finalContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = suggestedName;
            a.click();
            URL.revokeObjectURL(url);

            onSaveSuccess();
        }

        function onSaveSuccess() {
            state.sourceContent = '';
            state.targetContent = '';
            state.baselineContent = '';
            state.sourceFileName = '';
            state.targetFileName = '';
            state.baselineFileName = '';
            state.sourceFileType = 'markdown';
            state.targetFileType = 'markdown';

            // Reset editors to markdown mode
            sourceEditor.setOption('mode', 'markdown');
            targetEditor.setOption('mode', 'markdown');

            updateHeaderLabels();

            clearAllHighlights();
            showWelcomeText();

            alert('File saved successfully!');
        }

        function getMainBlock(text) {
            const parts = text.split(/\n---\n/);
            return parts[0] || '';
        }

        function extractWords(text) {
            const matches = text.match(/[\p{L}]+/gu) || [];
            return matches;
        }

        function generateStats(mainBlock) {
            const chars = mainBlock.length;
            const words = extractWords(mainBlock);
            const wordCount = words.length;
            const headings = mainBlock.match(/^#{1,6}\s/gm)?.length || 0;
            const hash = calculateHash(mainBlock);
            const timestamp = new Date().toISOString();
            
            return `## STATS\n` +
                   `- Characters (with spaces): ${chars}\n` +
                   `- Words: ${wordCount}\n` +
                   `- Headings count: ${headings}\n` +
                   `- SHA256 (main text block): ${hash}\n` +
                   `- Made at (UTC): ${timestamp}`;
        }

        // Generate stats as comments for TOML/YAML
        function generateStatsComment(contentForStats, fileType) {
            const chars = contentForStats.length;
            const words = extractWords(contentForStats);
            const wordCount = words.length;
            const hash = calculateHash(contentForStats);
            const timestamp = new Date().toISOString();

            // Count headings based on file type
            const text = targetEditor.getValue();
            let headings = 0;
            if (fileType === 'toml') {
                headings = (text.match(/^(title|h[1-6])\s*=/gm) || []).length;
            } else if (fileType === 'yaml') {
                headings = (text.match(/^(title|h[1-6]):/gm) || []).length;
            }

            return `# === STATS ===\n` +
                   `# Characters (with spaces): ${chars}\n` +
                   `# Words: ${wordCount}\n` +
                   `# Headings count: ${headings}\n` +
                   `# SHA256: ${hash}\n` +
                   `# Made at (UTC): ${timestamp}`;
        }

        // Generate word changes as comments for TOML/YAML
        function generateWordChangesComment(fileType) {
            const currentText = getTextForStats(targetEditor.getValue(), fileType);
            const baseText = getTextForStats(state.baselineContent, fileType);

            if (!baseText || baseText === currentText) {
                return '';
            }

            const baseWords = extractWords(baseText);
            const currentWords = extractWords(currentText);
            const changes = findWordChanges(baseWords, currentWords);

            if (changes.deleted.length === 0 && changes.added.length === 0 && changes.replaced.length === 0) {
                return '';
            }

            let result = '# === CHANGES ===\n';

            if (changes.deleted.length > 0) {
                result += '# Removed:\n';
                changes.deleted.slice(0, 10).forEach(w => {
                    result += `#   - ${w.word}\n`;
                });
            }

            if (changes.added.length > 0) {
                result += '# Added:\n';
                changes.added.slice(0, 10).forEach(w => {
                    result += `#   + ${w.word}\n`;
                });
            }

            if (changes.replaced.length > 0) {
                result += '# Replaced:\n';
                changes.replaced.slice(0, 10).forEach(w => {
                    result += `#   ${w.oldWord} → ${w.newWord}\n`;
                });
            }

            const totalChanges = changes.deleted.length + changes.added.length + changes.replaced.length;
            const totalWords = Math.max(baseWords.length, currentWords.length);
            const diffPercent = totalWords > 0 ? ((totalChanges / totalWords) * 100).toFixed(1) : 0;
            result += `# Overall: ${diffPercent}% difference, ${totalChanges} changes`;

            return result;
        }

        function generateWordChanges() {
            const currentText = getMainBlock(targetEditor.getValue());
            
            // Use baseline content for comparison in both modes
            const baseText = getMainBlock(state.baselineContent);
            
            if (!baseText || baseText === currentText) {
                return '';
            }
            
            const baseLines = baseText.split('\n');
            const currentLines = currentText.split('\n');
            
            // Track changes by line number and type
            const changesByLine = {
                deleted: [],    // { line, word }
                added: [],      // { line, word }
                replaced: []    // { line, oldWord, newWord }
            };
            
            const minLines = Math.min(baseLines.length, currentLines.length);
            
            // Compare line by line - same logic as highlighting
            for (let lineNum = 0; lineNum < minLines; lineNum++) {
                if (baseLines[lineNum] !== currentLines[lineNum]) {
                    const baseWords = extractWords(baseLines[lineNum]);
                    const currentWords = extractWords(currentLines[lineNum]);
                    
                    const changes = findWordChanges(baseWords, currentWords);
                    
                    changes.deleted.forEach(wordInfo => {
                        changesByLine.deleted.push({ line: lineNum + 1, word: wordInfo.word });
                    });
                    
                    changes.added.forEach(wordInfo => {
                        changesByLine.added.push({ line: lineNum + 1, word: wordInfo.word });
                    });
                    
                    changes.replaced.forEach(wordInfo => {
                        changesByLine.replaced.push({ 
                            line: lineNum + 1, 
                            oldWord: wordInfo.oldWord, 
                            newWord: wordInfo.newWord 
                        });
                    });
                }
            }
            
            // Handle added lines at the end
            if (currentLines.length > baseLines.length) {
                for (let i = minLines; i < currentLines.length; i++) {
                    const words = extractWords(currentLines[i]);
                    words.forEach(word => {
                        changesByLine.added.push({ line: i + 1, word });
                    });
                }
            }
            
            // Handle removed lines at the end
            if (baseLines.length > currentLines.length) {
                for (let i = minLines; i < baseLines.length; i++) {
                    const words = extractWords(baseLines[i]);
                    words.forEach(word => {
                        changesByLine.deleted.push({ line: i + 1, word });
                    });
                }
            }
            
            // Calculate total changes
            const totalChanges = changesByLine.deleted.length + 
                                changesByLine.added.length + 
                                changesByLine.replaced.length;
            
            if (totalChanges === 0) {
                return '';
            }
            
            const baseWordCount = extractWords(baseText).length;
            const currentWordCount = extractWords(currentText).length;
            const totalWords = Math.max(baseWordCount, currentWordCount);
            const diffPercent = totalWords > 0 ? ((totalChanges / totalWords) * 100).toFixed(1) : 0;
            
            let changesText = '## CHANGES\n\n';
            
            if (changesByLine.deleted.length > 0) {
                changesText += '### Removed\n';
                changesByLine.deleted.slice(0, 10).forEach(change => {
                    changesText += `Line ${change.line}: − \`${change.word}\`\n`;
                });
                changesText += '\n';
            }
            
            if (changesByLine.added.length > 0) {
                changesText += '### Added\n';
                changesByLine.added.slice(0, 10).forEach(change => {
                    changesText += `Line ${change.line}: + \`${change.word}\`\n`;
                });
                changesText += '\n';
            }
            
            if (changesByLine.replaced.length > 0) {
                changesText += '### Replaced\n';
                changesByLine.replaced.slice(0, 10).forEach(change => {
                    changesText += `Line ${change.line}: \`${change.oldWord}\` → \`${change.newWord}\`\n`;
                });
                changesText += '\n';
            }
            
            changesText += `### Overall\n`;
            changesText += `Difference: ${diffPercent}% / Changes: ${totalChanges}`;
            
            return changesText.trim();
        }

        function calculateHash(text) {
            let hash = 0;
            for (let i = 0; i < text.length; i++) {
                const chr = text.charCodeAt(i);
                hash = ((hash << 5) - hash) + chr;
                hash = hash & hash;
            }
            return Math.abs(hash).toString(16).padStart(8, '0');
        }

        function adjustOffset(delta) {
            setOffset(state.offset + delta);
        }

        function setOffset(value) {
            state.offset = value;
            document.getElementById('offsetValue').value = value;
            const activeEditor = targetEditor.hasFocus() ? targetEditor : sourceEditor;
            const otherEditor = activeEditor === targetEditor ? sourceEditor : targetEditor;
            updateMirrorLine(activeEditor, otherEditor);
        }

        function toggleTheme() {
            state.theme = state.theme === 'light' ? 'dark' : 'light';
            localStorage.setItem('theme', state.theme);
            applyTheme(state.theme);
        }

        function applyTheme(theme) {
            document.body.classList.toggle('dark', theme === 'dark');
            const cmTheme = theme === 'dark' ? 'monokai' : 'default';
            sourceEditor?.setOption('theme', cmTheme);
            targetEditor?.setOption('theme', cmTheme);
        }

        function updateLiveFooter(side, text) {
            // Determine file type for this side
            const fileType = side === 'left' ? state.sourceFileType : state.targetFileType;

            // Get text content based on file type (values only for TOML/YAML)
            const contentForStats = getTextForStats(text, fileType);

            const chars = contentForStats.length;
            const words = extractWords(contentForStats);
            const wordCount = words.length;

            // Count headings based on file type
            let headings = 0;
            if (fileType === 'toml') {
                // Count TOML heading keys: title, h1, h2, h3, h4, h5, h6
                headings = (text.match(/^(title|h[1-6])\s*=/gm) || []).length;
            } else if (fileType === 'yaml') {
                // Count YAML heading keys: title, h1, h2, h3, h4, h5, h6
                headings = (text.match(/^(title|h[1-6]):/gm) || []).length;
            } else {
                // Markdown headings
                headings = (getMainBlock(text).match(/^#{1,6}\s/gm) || []).length;
            }

            // Get keywords based on file type (from original text structure, not extracted values)
            const keywords = getKeywordsForFileType(text, fileType);
            state.keywords[side === 'left' ? 'left' : 'right'] = keywords;

            const keywordFreqs = keywords.map(kw => {
                // Count occurrences in the extracted content (values only)
                const count = countOccurrences(contentForStats, kw);
                const percent = wordCount > 0 ? (count / wordCount * 100) : 0;
                const wordCount2 = kw.split(/\s+/).length;
                return { keyword: kw, count, percent, wordCount: wordCount2 };
            }).sort((a, b) => b.count - a.count);
            
            const bigramFreqs = getNGramsWithFrequency(words, 2, wordCount).slice(0, 40);
            const trigramFreqs = getNGramsWithFrequency(words, 3, wordCount).slice(0, 40);
            
            state.nlpData[side === 'left' ? 'left' : 'right'] = {
                lemmas: getLemmasWithFrequency(words, wordCount).slice(0, 40),
                bigrams: bigramFreqs,
                trigrams: trigramFreqs,
                keywords: keywordFreqs
            };
            
            const prefix = side === 'left' ? 'left' : 'right';
            document.getElementById(`${prefix}Chars`).textContent = chars;
            document.getElementById(`${prefix}Words`).textContent = wordCount;
            document.getElementById(`${prefix}Headings`).textContent = headings;
            
            const keywordsEl = document.getElementById(`${prefix}Keywords`);
            keywordsEl.innerHTML = '';
            keywordFreqs.forEach(item => {
                const percent = item.percent.toFixed(2);
                const color = getKeywordDensityColor(item.percent, item.wordCount);
                
                const chip = document.createElement('span');
                chip.className = `keyword-chip ${color}`;
                chip.textContent = `${item.keyword} (${item.count} • ${percent}%)`;
                chip.onclick = () => highlightKeyword(item.keyword, side);
                keywordsEl.appendChild(chip);
            });
        }

        function getKeywordDensityColor(percent, wordCount) {
            const p = parseFloat(percent);
            
            if (wordCount === 1) {
                if (p < 1.0) return 'gray';
                if (p < 2.0) return 'blue';
                if (p < 3.0) return 'green';
                return 'red';
            } else if (wordCount === 2) {
                if (p < 0.5) return 'gray';
                if (p < 1.0) return 'blue';
                if (p < 2.0) return 'green';
                return 'red';
            } else {
                if (p < 0.3) return 'gray';
                if (p < 0.7) return 'blue';
                if (p < 1.0) return 'green';
                return 'red';
            }
        }

        function extractKeywords(text) {
            const keywords = [];

            // Only match Keywords: at the beginning of a line
            const inlineMatch = text.match(/^Keywords:\s*([^\n]+)/im);
            if (inlineMatch) {
                const items = inlineMatch[1].split(/[,;]/);
                keywords.push(...items.map(k => k.trim()).filter(k => k));
            }
            
            const sectionMatch = text.match(/^#+ Keywords\n([\s\S]*?)(?=^#+ |$)/mi);
            if (sectionMatch) {
                const section = sectionMatch[1];
                const items = section.split(/[,;\n]/);
                keywords.push(...items.map(k => k.replace(/^[-*]\s*/, '').trim()).filter(k => k));
            }
            
            return [...new Set(keywords)];
        }

        function countOccurrences(text, keyword) {
            const keywordLower = keyword.toLowerCase();
            const textLower = text.toLowerCase();
            let count = 0;
            let searchPos = 0;
            
            while (searchPos < textLower.length) {
                const index = textLower.indexOf(keywordLower, searchPos);
                if (index === -1) break;
                
                const beforeOk = index === 0 || !/[\p{L}]/u.test(text[index - 1]);
                const afterOk = index + keyword.length >= text.length || 
                               !/[\p{L}]/u.test(text[index + keyword.length]);
                
                if (beforeOk && afterOk) {
                    count++;
                }
                
                searchPos = index + 1;
            }
            
            return count;
        }

        function getNGramsWithFrequency(words, n, totalWords) {
            const ngrams = {};
            for (let i = 0; i <= words.length - n; i++) {
                const ngram = words.slice(i, i + n).join(' ').toLowerCase();
                ngrams[ngram] = (ngrams[ngram] || 0) + 1;
            }
            
            return Object.entries(ngrams)
                .map(([text, count]) => ({
                    text,
                    count,
                    percent: totalWords > 0 ? (count / totalWords * 100) : 0
                }))
                .sort((a, b) => b.count - a.count);
        }

        function getLemmasWithFrequency(words, totalWords) {
            const lemmas = {};
            const stopWords = new Set(['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 
                                      'of', 'with', 'by', 'from', 'as', 'is', 'was', 'are', 'were',
                                      'i', 'w', 'z', 'na', 'do', 'od', 'po', 'za', 'o']);
            
            words.forEach(word => {
                const lower = word.toLowerCase();
                if (!stopWords.has(lower) && lower.length > 2) {
                    lemmas[lower] = (lemmas[lower] || 0) + 1;
                }
            });
            
            return Object.entries(lemmas)
                .map(([word, count]) => ({
                    word,
                    count,
                    percent: totalWords > 0 ? (count / totalWords * 100) : 0
                }))
                .sort((a, b) => b.count - a.count);
        }

        function highlightKeyword(keyword, side) {
            const editor = side === 'left' ? sourceEditor : targetEditor;
            
            editor.getAllMarks().forEach(mark => {
                if (mark.className === 'cm-keyword-focus') {
                    mark.clear();
                }
            });
            
            const text = editor.getValue();
            const keywordLower = keyword.toLowerCase();
            const textLower = text.toLowerCase();
            
            let searchPos = 0;
            while (searchPos < textLower.length) {
                const index = textLower.indexOf(keywordLower, searchPos);
                if (index === -1) break;
                
                const beforeOk = index === 0 || !/[\p{L}]/u.test(text[index - 1]);
                const afterOk = index + keyword.length >= text.length || 
                               !/[\p{L}]/u.test(text[index + keyword.length]);
                
                if (beforeOk && afterOk) {
                    const from = editor.posFromIndex(index);
                    const to = editor.posFromIndex(index + keyword.length);
                    editor.markText(from, to, { className: 'cm-keyword-focus' });
                }
                
                searchPos = index + 1;
            }
        }

        function applyWordDiffHighlights() {
            if (state.mode !== 'proofread') return;
            
            clearDiffHighlights();
            
            const baseText = state.baselineContent;
            const currentText = targetEditor.getValue();
            
            if (!baseText || baseText === currentText) return;
            
            const baseLines = baseText.split('\n');
            const currentLines = currentText.split('\n');
            
            const minLines = Math.min(baseLines.length, currentLines.length);
            
            // Compare line by line
            for (let lineNum = 0; lineNum < minLines; lineNum++) {
                if (baseLines[lineNum] !== currentLines[lineNum]) {
                    const baseWords = extractWords(baseLines[lineNum]);
                    const currentWords = extractWords(currentLines[lineNum]);
                    
                    const changes = findWordChanges(baseWords, currentWords);
                    
                    // Highlight deleted words in source editor
                    changes.deleted.forEach(wordInfo => {
                        highlightWordInLine(sourceEditor, lineNum, wordInfo.word, wordInfo.index, 'cm-diff-delete');
                    });
                    
                    // Highlight added words in target editor
                    changes.added.forEach(wordInfo => {
                        highlightWordInLine(targetEditor, lineNum, wordInfo.word, wordInfo.index, 'cm-diff-insert');
                    });
                    
                    // Highlight replaced words in both editors
                    changes.replaced.forEach(wordInfo => {
                        highlightWordInLine(sourceEditor, lineNum, wordInfo.oldWord, wordInfo.index, 'cm-diff-replace');
                        highlightWordInLine(targetEditor, lineNum, wordInfo.newWord, wordInfo.index, 'cm-diff-replace');
                    });
                }
            }
            
            // Handle added lines at the end
            if (currentLines.length > baseLines.length) {
                for (let i = minLines; i < currentLines.length; i++) {
                    const words = extractWords(currentLines[i]);
                    words.forEach((word, idx) => {
                        highlightWordInLine(targetEditor, i, word, idx, 'cm-diff-insert');
                    });
                }
            }
            
            // Handle removed lines at the end
            if (baseLines.length > currentLines.length) {
                for (let i = minLines; i < baseLines.length; i++) {
                    const words = extractWords(baseLines[i]);
                    words.forEach((word, idx) => {
                        highlightWordInLine(sourceEditor, i, word, idx, 'cm-diff-delete');
                    });
                }
            }
        }
        
        function findWordChanges(baseWords, currentWords) {
            const changes = {
                deleted: [],
                added: [],
                replaced: []
            };
            
            let baseIndex = 0;
            let currentIndex = 0;
            
            while (baseIndex < baseWords.length || currentIndex < currentWords.length) {
                if (baseIndex >= baseWords.length) {
                    // All remaining current words are added
                    changes.added.push({ word: currentWords[currentIndex], index: currentIndex });
                    currentIndex++;
                } else if (currentIndex >= currentWords.length) {
                    // All remaining base words are deleted
                    changes.deleted.push({ word: baseWords[baseIndex], index: baseIndex });
                    baseIndex++;
                } else if (baseWords[baseIndex] === currentWords[currentIndex]) {
                    // Words match
                    baseIndex++;
                    currentIndex++;
                } else {
                    let found = false;
                    
                    // Look ahead in base for current word (deletion case)
                    for (let i = 1; i <= 3 && baseIndex + i < baseWords.length; i++) {
                        if (baseWords[baseIndex + i] === currentWords[currentIndex]) {
                            // Found match, so words in between were deleted
                            for (let j = 0; j < i; j++) {
                                changes.deleted.push({ word: baseWords[baseIndex + j], index: baseIndex + j });
                            }
                            baseIndex += i;
                            found = true;
                            break;
                        }
                    }
                    
                    if (!found) {
                        // Look ahead in current for base word (addition case)
                        for (let i = 1; i <= 3 && currentIndex + i < currentWords.length; i++) {
                            if (currentWords[currentIndex + i] === baseWords[baseIndex]) {
                                // Found match, so words in between were added
                                for (let j = 0; j < i; j++) {
                                    changes.added.push({ word: currentWords[currentIndex + j], index: currentIndex + j });
                                }
                                currentIndex += i;
                                found = true;
                                break;
                            }
                        }
                    }
                    
                    if (!found) {
                        // Words are different - replacement
                        changes.replaced.push({ 
                            oldWord: baseWords[baseIndex], 
                            newWord: currentWords[currentIndex], 
                            index: baseIndex 
                        });
                        baseIndex++;
                        currentIndex++;
                    }
                }
            }
            
            return changes;
        }
        
        function highlightWordInLine(editor, lineNum, word, wordIndexInLine, className) {
            const line = editor.getLine(lineNum);
            if (!line) return;
            
            const words = extractWords(line);
            if (wordIndexInLine >= words.length) return;
            
            let currentWordIndex = 0;
            
            for (let i = 0; i < line.length; i++) {
                if (/[\p{L}]/u.test(line[i])) {
                    if (currentWordIndex === wordIndexInLine) {
                        let wordEnd = i;
                        while (wordEnd < line.length && /[\p{L}]/u.test(line[wordEnd])) {
                            wordEnd++;
                        }
                        
                        const from = { line: lineNum, ch: i };
                        const to = { line: lineNum, ch: wordEnd };
                        editor.markText(from, to, { className });
                        return;
                    }
                    
                    // Skip to end of current word
                    while (i < line.length && /[\p{L}]/u.test(line[i])) {
                        i++;
                    }
                    currentWordIndex++;
                    i--;
                }
            }
        }

        function clearDiffHighlights() {
            [sourceEditor, targetEditor].forEach(editor => {
                editor.getAllMarks().forEach(mark => {
                    if (mark.className && mark.className.includes('cm-diff-')) {
                        mark.clear();
                    }
                });
            });
        }

        function clearAllHighlights() {
            [sourceEditor, targetEditor].forEach(editor => {
                editor.getAllMarks().forEach(mark => {
                    if (mark.className !== 'cm-mirror-line') {
                        mark.clear();
                    }
                });
            });
        }

        function applyGrammarCheck() {
            if (!state.grammarEnabled) {
                targetEditor.getAllMarks().forEach(mark => {
                    if (mark.className === 'cm-grammar-error') {
                        mark.clear();
                    }
                });
                return;
            }
            
            const text = targetEditor.getValue();
            const issues = [];
            
            const doubleSpaceRegex = /  +/g;
            let match;
            while ((match = doubleSpaceRegex.exec(text)) !== null) {
                issues.push({ start: match.index, end: match.index + match[0].length, type: 'double-space' });
            }
            
            const repeatedWordsRegex = /\b(\w+)\s+\1\b/gi;
            while ((match = repeatedWordsRegex.exec(text)) !== null) {
                issues.push({ start: match.index, end: match.index + match[0].length, type: 'repeated-word' });
            }
            
            const multiplePunctuationRegex = /[.!?,;]{2,}/g;
            while ((match = multiplePunctuationRegex.exec(text)) !== null) {
                if (match[0] !== '...' && match[0] !== '....' && match[0] !== '?!' && match[0] !== '!?') {
                    issues.push({ start: match.index, end: match.index + match[0].length, type: 'multiple-punctuation' });
                }
            }
            
            const missingSpaceRegex = /[.!?,;:][a-zA-Z]/g;
            while ((match = missingSpaceRegex.exec(text)) !== null) {
                issues.push({ start: match.index, end: match.index + match[0].length, type: 'missing-space' });
            }
            
            const capitalizationRegex = /[.!?]\s+[a-z]/g;
            while ((match = capitalizationRegex.exec(text)) !== null) {
                issues.push({ start: match.index, end: match.index + match[0].length, type: 'capitalization' });
            }
            
            const commonMisspellings = {
                'recieve': 'receive',
                'beleive': 'believe',
                'occured': 'occurred',
                'seperate': 'separate',
                'untill': 'until',
                'wich': 'which',
                'teh': 'the',
                'adn': 'and',
                'becuase': 'because',
                'definately': 'definitely',
                'occassion': 'occasion',
                'priviledge': 'privilege',
                'concensus': 'consensus',
                'accomodate': 'accommodate'
            };
            
            for (const [wrong, correct] of Object.entries(commonMisspellings)) {
                const misspellingRegex = new RegExp(`\\b${wrong}\\b`, 'gi');
                while ((match = misspellingRegex.exec(text)) !== null) {
                    issues.push({ 
                        start: match.index, 
                        end: match.index + match[0].length, 
                        type: 'spelling',
                        suggestion: correct
                    });
                }
            }
            
            const openQuotes = (text.match(/"/g) || []).length;
            const closeQuotes = (text.match(/"/g) || []).length;
            if (openQuotes % 2 !== 0 || closeQuotes % 2 !== 0) {
                issues.push({ start: 0, end: 10, type: 'unclosed-quotes' });
            }
            
            const openParens = (text.match(/\(/g) || []).length;
            const closeParens = (text.match(/\)/g) || []).length;
            if (openParens !== closeParens) {
                issues.push({ start: 0, end: 10, type: 'unmatched-parentheses' });
            }
            
            issues.forEach(issue => {
                const from = targetEditor.posFromIndex(issue.start);
                const to = targetEditor.posFromIndex(issue.end);
                
                let cssStyle = 'text-decoration: underline wavy red';
                if (issue.type === 'spelling') {
                    cssStyle = 'text-decoration: underline wavy red; background: rgba(255,0,0,0.1)';
                } else if (issue.type === 'capitalization') {
                    cssStyle = 'text-decoration: underline wavy orange';
                } else if (issue.type === 'double-space' || issue.type === 'missing-space') {
                    cssStyle = 'text-decoration: underline wavy blue';
                }
                
                targetEditor.markText(from, to, {
                    className: 'cm-grammar-error',
                    css: cssStyle,
                    title: issue.suggestion ? `Suggestion: ${issue.suggestion}` : issue.type
                });
            });
        }

        function updateNLPSidebar(side) {
            const dataKey = side === 'source' ? 'left' : 'right';
            const prefix = side === 'source' ? 'source' : 'target';
            const highlightSide = side === 'source' ? 'left' : 'right';

            const keywords = state.nlpData[dataKey].keywords || [];

            const lemmasTable = document.getElementById(`${prefix}LemmasTable`);
            lemmasTable.innerHTML = '';
            (state.nlpData[dataKey].lemmas || []).forEach(lemma => {
                const row = lemmasTable.insertRow();
                const percent = lemma.percent.toFixed(2);
                const color = getKeywordDensityColor(lemma.percent, 1);

                const wordCell = row.insertCell(0);
                wordCell.textContent = lemma.word;

                const isKeyword = keywords.some(kw =>
                    kw.keyword.toLowerCase() === lemma.word.toLowerCase()
                );
                if (isKeyword) {
                    wordCell.className = 'keyword-match';
                }
                wordCell.onclick = () => highlightKeyword(lemma.word, highlightSide);

                row.insertCell(1).textContent = lemma.count;
                const percentCell = row.insertCell(2);
                percentCell.textContent = `${percent}%`;
                percentCell.className = `density-${color}`;
            });

            const bigramsTable = document.getElementById(`${prefix}BigramsTable`);
            bigramsTable.innerHTML = '';
            (state.nlpData[dataKey].bigrams || []).forEach(bigram => {
                const row = bigramsTable.insertRow();
                const percent = bigram.percent.toFixed(2);
                const color = getKeywordDensityColor(bigram.percent, 2);

                const textCell = row.insertCell(0);
                textCell.textContent = bigram.text;

                const isKeyword = keywords.some(kw =>
                    kw.keyword.toLowerCase() === bigram.text.toLowerCase()
                );
                if (isKeyword) {
                    textCell.className = 'keyword-match';
                }
                textCell.onclick = () => highlightKeyword(bigram.text, highlightSide);

                row.insertCell(1).textContent = bigram.count;
                const percentCell = row.insertCell(2);
                percentCell.textContent = `${percent}%`;
                percentCell.className = `density-${color}`;
            });

            const trigramsTable = document.getElementById(`${prefix}TrigramsTable`);
            trigramsTable.innerHTML = '';
            (state.nlpData[dataKey].trigrams || []).forEach(trigram => {
                const row = trigramsTable.insertRow();
                const percent = trigram.percent.toFixed(2);
                const color = getKeywordDensityColor(trigram.percent, 3);

                const textCell = row.insertCell(0);
                textCell.textContent = trigram.text;

                const isKeyword = keywords.some(kw =>
                    kw.keyword.toLowerCase() === trigram.text.toLowerCase()
                );
                if (isKeyword) {
                    textCell.className = 'keyword-match';
                }
                textCell.onclick = () => highlightKeyword(trigram.text, highlightSide);

                row.insertCell(1).textContent = trigram.count;
                const percentCell = row.insertCell(2);
                percentCell.textContent = `${percent}%`;
                percentCell.className = `density-${color}`;
            });
        }

        // Set file format manually (from selector)
        function setFileFormat(format) {
            state.targetFileType = format;
            state.sourceFileType = format;

            // Map format to CodeMirror mode
            const modeMap = {
                'markdown': 'markdown',
                'text': 'text/plain',
                'json': 'application/json',
                'toml': 'toml',
                'yaml': 'yaml'
            };

            const mode = modeMap[format] || 'markdown';
            sourceEditor.setOption('mode', mode);
            targetEditor.setOption('mode', mode);

            // Update extension
            const extMap = {
                'markdown': '.md',
                'text': '.txt',
                'json': '.json',
                'toml': '.toml',
                'yaml': '.yaml'
            };
            state.targetFileExtension = extMap[format] || '.md';

            // Refresh footer stats
            if (!state.welcomeActive) {
                updateLiveFooter('left', sourceEditor.getValue());
                updateLiveFooter('right', targetEditor.getValue());
            }
        }

        function updateUI() {
            document.getElementById('offsetValue').value = state.offset;
            document.getElementById('lockScroll').checked = state.lockScroll;
            document.getElementById('grammarCheck').checked = state.grammarEnabled;
            document.getElementById('fileFormatSelector').value = state.targetFileType;
        }
    </script>
</body>
</html>
